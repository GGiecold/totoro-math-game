<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Totoro Math Game</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4a90e2">
  <style>
    body { margin:0; overflow:hidden; background:#87ceeb; font-family:Arial,sans-serif; }
    #ui { position:absolute; top:10px; left:10px; color:white; font-size:18px; text-shadow:1px 1px 2px black; }
    button { margin:5px; padding:5px 10px; font-size:16px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="easyBtn">Easy</button>
    <button id="normalBtn">Normal</button>
    <button id="hardBtn">Hard</button>
    <div id="info"></div>
  </div>
  <canvas id="gameCanvas"></canvas>
  <script>
    const C = document.getElementById("gameCanvas");
    const ctx = C.getContext("2d");
    let W, H;
    function resize() { W = C.width = window.innerWidth; H = C.height = window.innerHeight; }
    window.addEventListener("resize", resize); resize();

    const totoroImg = new Image();
    totoroImg.src = "icons/totoro.png";

    function generateProblem() {
      let a = Math.floor(Math.random() * 90) + 10;
      let b = Math.floor(Math.random() * 90) + 10;
      let op = Math.random() < 0.5 ? "+" : "-";
      if (op === "-" && b > a) [a, b] = [b, a];
      return { text: a + " " + op + " " + b, answer: op==="+" ? a+b : a-b };
    }

    class Sprite {
      constructor(x, y, type, problem, speed) {
        this.x = x; this.y = y; this.type=type; this.problem=problem;
        this.r = 30; this.speed = speed;
        this.wobblePhase=Math.random()*Math.PI*2;
      }
      draw() {
        if(this.type==="soot"){
          ctx.beginPath();
          ctx.fillStyle = "black";
          ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
          ctx.fill();
          ctx.fillStyle="white";
          ctx.beginPath(); ctx.arc(this.x-10,this.y-5,6,0,Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(this.x+10,this.y-5,6,0,Math.PI*2); ctx.fill();
          ctx.fillStyle="black";
          ctx.beginPath(); ctx.arc(this.x-10,this.y-5,2,0,Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(this.x+10,this.y-5,2,0,Math.PI*2); ctx.fill();
          ctx.fillStyle="white";
          ctx.font="16px Arial"; ctx.textAlign="center";
          ctx.fillText(this.problem.text,this.x,this.y+30);
        } else if(this.type==="heart"){
          ctx.fillStyle="red";
          ctx.beginPath();
          ctx.moveTo(this.x,this.y);
          ctx.bezierCurveTo(this.x-20,this.y-20,this.x-40,this.y+10,this.x,this.y+40);
          ctx.bezierCurveTo(this.x+40,this.y+10,this.x+20,this.y-20,this.x,this.y);
          ctx.fill();
          ctx.fillStyle="white"; ctx.font="14px Arial"; ctx.textAlign="center";
          ctx.fillText("Chloe",this.x,this.y+10);
        } else if(this.type==="bird"){
          ctx.fillStyle="yellow";
          ctx.beginPath();
          ctx.ellipse(this.x,this.y,25,18,0,0,Math.PI*2);
          ctx.fill();
          ctx.fillStyle="orange";
          ctx.beginPath(); ctx.moveTo(this.x+25,this.y); ctx.lineTo(this.x+35,this.y+5); ctx.lineTo(this.x+25,this.y+10); ctx.closePath(); ctx.fill();
          ctx.fillStyle="black"; ctx.beginPath(); ctx.arc(this.x-10,this.y-5,3,0,Math.PI*2); ctx.fill();
        }
      }
      update() {
        this.y -= this.speed;
        if(this.type==="bird"){
          this.x += Math.sin(this.y/30+this.wobblePhase)*0.5;
        }
      }
    }

    class Game {
      constructor() {
        this.sprites=[]; this.score=0; this.lives=5;
        this.running=false; this.spawnInterval=2000; this.lastSpawn=0;
        this.currentTarget=generateProblem();
        this.difficulty="normal";
        this.spawnCount=0;
      }
      setDifficulty(level) {
        this.difficulty = level;
        if(level==="easy"){ this.spawnInterval=2500; this.baseSpeed=0.4; }
        else if(level==="normal"){ this.spawnInterval=2000; this.baseSpeed=0.7; }
        else if(level==="hard"){ this.spawnInterval=1500; this.baseSpeed=1.2; }
      }
      start() {
        this.score=0; this.lives=5; this.sprites=[];
        this.running=true; this.lastSpawn=0; this.spawnCount=0;
        this.currentTarget=generateProblem();
        this.loop(performance.now());
      }
      spawn(forceCorrect=false) {
        this.spawnCount++;
        if(this.spawnCount % 20 === 0){
          this.sprites.push(new Sprite(Math.random()*(W-60)+30,H-80,"bird",null,this.baseSpeed*0.5));
          return;
        }
        if(this.spawnCount % 9 === 0){
          this.sprites.push(new Sprite(Math.random()*(W-60)+30,H-80,"heart",null,this.baseSpeed*0.4));
          return;
        }
        let problem = generateProblem();
        if(forceCorrect){
          let a = Math.floor(Math.random()*90)+10;
          let op = Math.random()<0.5?"+":"-";
          let b;
          if(op==="+") b = this.currentTarget.answer - a;
          else b = a - this.currentTarget.answer;
          if(b<10||b>99){
            problem = { text: this.currentTarget.answer+"-0", answer:this.currentTarget.answer };
          } else {
            problem = { text: a+" "+op+" "+b, answer: this.currentTarget.answer };
          }
        }
        this.sprites.push(new Sprite(Math.random()*(W-60)+30,H-80,"soot",problem,this.baseSpeed + Math.random()*0.3));
      }
      loop(ts) {
        if(!this.running) return;
        ctx.fillStyle="#87ceeb"; ctx.fillRect(0,0,W,H);
        ctx.fillStyle="green"; ctx.fillRect(0,H-40,W,40);
        if(totoroImg.complete){
          ctx.drawImage(totoroImg,W/2-50,H-120,100,100);
        } else {
          ctx.fillStyle="gray";
          ctx.beginPath(); ctx.arc(W/2,H-60,40,0,Math.PI*2); ctx.fill();
        }
        if(ts - this.lastSpawn > this.spawnInterval) {
          if(this.spawnCount % Math.floor(Math.random()*5+4) === 0){
            this.spawn(true);
          } else {
            this.spawn();
          }
          this.lastSpawn = ts;
        }
        this.sprites.forEach(s=>{ s.update(); s.draw(); });
        this.sprites=this.sprites.filter(s=>s.y+s.r>0);
        document.getElementById("info").innerText=
          "Score: "+this.score+" Lives: "+this.lives+" | Target: "+this.currentTarget.answer;
        requestAnimationFrame(this.loop.bind(this));
      }
    }

    const game=new Game();
    game.setDifficulty("normal");
    document.getElementById("startBtn").onclick=()=>game.start();
    document.getElementById("easyBtn").onclick=()=>game.setDifficulty("easy");
    document.getElementById("normalBtn").onclick=()=>game.setDifficulty("normal");
    document.getElementById("hardBtn").onclick=()=>game.setDifficulty("hard");

    C.addEventListener("click", e=>{
      if(!game.running) return;
      const rect=C.getBoundingClientRect();
      const mx=e.clientX-rect.left,my=e.clientY-rect.top;
      game.sprites.forEach((s,i)=>{
        if(s.type!=="soot") return;
        const dx=mx-s.x,dy=my-s.y;
        if(dx*dx+dy*dy<=s.r*s.r){
          if(s.problem.answer===game.currentTarget.answer){
            game.score++; game.currentTarget=generateProblem();
          } else {
            game.lives--; if(game.lives<=0){ game.running=false; alert("Game Over!"); }
          }
          game.sprites.splice(i,1);
        }
      });
    });
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(()=>console.log("SW registered"))
        .catch(err=>console.error("SW failed:",err));
    }
  </script>
</body>
</html>
